<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Definitive Guide to GraphRAG: Power Query vs. DuckDB</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* gray-50 */
            color: #111827; /* gray-900 */
        }
        .nav-link {
            position: relative;
            transition: color 0.3s;
        }
        .nav-link::after {
            content: '';
            position: absolute;
            width: 0;
            height: 2px;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1d4ed8; /* blue-700 */
            transition: width 0.3s ease-in-out;
        }
        .nav-link:hover::after, .nav-link.active::after {
            width: 100%;
        }
        .tab-btn.active {
            background-color: #1d4ed8;
            color: #ffffff;
            border-color: #1d4ed8;
        }
        .tab-btn {
            transition: all 0.2s ease-in-out;
        }
        .code-block {
            font-family: 'Source Code Pro', monospace;
        }
        .flow-step {
            display: flex;
            align-items: center;
        }
        .flow-step-icon {
            flex-shrink: 0;
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background-color: #eef2ff; /* indigo-100 */
            color: #4338ca; /* indigo-700 */
        }
        .flow-step-content {
            margin-left: 1rem;
        }
        .comparison-table td, .comparison-table th {
            padding: 1rem;
            border: 1px solid #e5e7eb; /* gray-200 */
        }
        .comparison-table th {
            background-color: #f3f4f6; /* gray-100 */
        }
    </style>
</head>
<body class="antialiased">
    <!-- Chosen Palette: Blue Gray -->
    <!-- Application Structure Plan: The app is designed as a strategic guide. It starts by defining Microsoft's GraphRAG and its specific data input needs. Then, it presents two competing workflows ("Path A: Power Query" and "Path B: DuckDB") in an interactive, tabbed format, showing the step-by-step process for each. This structure directly facilitates comparison. The "Definitive Comparison" section uses a detailed table to quantitatively and qualitatively score each path on key metrics. The final recommendations section offers nuanced advice based on user persona (e.g., "If you are a Power Query purist..." vs. "If you value speed and automation..."), making the guide actionable. -->
    <!-- Visualization & Content Choices: Report Info -> The core of the research is comparing two distinct technical workflows. Goal -> Make these multi-step, abstract processes easy to understand and compare. Viz/Presentation Method -> Interactive tabbed sections for each workflow path, built with HTML/JS. Interaction -> Users click tabs for "Step 1", "Step 2", etc., to see the specific actions and code/UI descriptions for that stage. Justification -> This breaks down the complexity and allows for a direct, side-by-side mental comparison of the effort and tools required for each path, which is more effective than a long, linear document. Custom SVG icons are used to visually anchor key concepts like data sources, transformations, and outputs. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <header class="bg-white/90 backdrop-blur-lg sticky top-0 z-50 border-b border-gray-200">
        <nav class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <div class="flex-shrink-0">
                        <a href="#hero" class="text-xl font-bold text-blue-700">The GraphRAG Guide</a>
                    </div>
                    <div class="hidden md:block">
                        <div class="ml-10 flex items-baseline space-x-4">
                            <a href="#graphrag-intro" class="nav-link px-3 py-2 rounded-md text-sm font-medium">GraphRAG Intro</a>
                            <a href="#powerquery-path" class="nav-link px-3 py-2 rounded-md text-sm font-medium">Power Query Path</a>
                            <a href="#duckdb-path" class="nav-link px-3 py-2 rounded-md text-sm font-medium">DuckDB Path</a>
                            <a href="#comparison" class="nav-link px-3 py-2 rounded-md text-sm font-medium">Comparison</a>
                            <a href="#recommendation" class="nav-link px-3 py-2 rounded-md text-sm font-medium">Recommendation</a>
                        </div>
                    </div>
                </div>
                 <div class="hidden md:block">
                    <a href="https://github.com/kairin/google-gemini-codes/tree/data-tool-analyzer" target="_blank" rel="noopener noreferrer" class="flex items-center text-sm font-medium text-gray-600 hover:text-blue-700 transition-colors">
                        <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 4.418 2.865 8.168 6.839 9.492.5.092.682-.217.682-.482 0-.237-.009-.868-.014-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.031-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.378.203 2.398.1 2.65.64.7 1.028 1.595 1.028 2.688 0 3.848-2.338 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.001 10.001 0 0022 12c0-5.523-4.477-10-10-10z" clip-rule="evenodd"></svg>
                        View Project on GitHub
                    </a>
                </div>
            </div>
        </nav>
    </header>

    <main>
        <section id="hero" class="py-20 md:py-28 text-center bg-white">
            <div class="container mx-auto px-4 sm:px-6 lg:px-8">
                <h1 class="text-4xl md:text-5xl font-bold tracking-tight leading-tight text-gray-900">From Tables to Insights: Your Definitive Guide to GraphRAG</h1>
                <p class="mt-6 max-w-3xl mx-auto text-lg md:text-xl text-gray-600">You have data in tables. You want to unlock its hidden connections and empower AI to reason over it. This guide provides a definitive comparison of two paths to prepare your data for Microsoft's GraphRAG framework: the familiar world of **Power Query** vs. the powerful, modern approach of **DuckDB**.</p>
            </div>
        </section>

        <section id="graphrag-intro" class="py-20 md:py-24">
            <div class="container mx-auto px-4 sm:px-6 lg:px-8">
                <div class="text-center mb-16">
                    <h2 class="text-3xl md:text-4xl font-bold text-gray-900">Understanding Microsoft's GraphRAG</h2>
                    <p class="mt-4 max-w-3xl mx-auto text-lg text-gray-600">At its core, GraphRAG creates a knowledge graph from your text data to provide richer, more reliable context to Large Language Models (LLMs), dramatically improving question-answering capabilities.</p>
                </div>
                <div class="max-w-6xl mx-auto bg-white p-8 rounded-xl border border-gray-200">
                    <h3 class="text-2xl font-semibold text-center mb-8">The GraphRAG Indexing Pipeline</h3>
                    <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-8">
                        <div class="flow-step">
                            <div class="flow-step-icon"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg></div>
                            <div class="flow-step-content"><h4 class="font-bold">1. Ingest Text</h4><p class="text-sm text-gray-500">Reads raw text from files (CSV, JSON, TXT).</p></div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-step-icon"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" /></svg></div>
                            <div class="flow-step-content"><h4 class="font-bold">2. Extract Entities</h4><p class="text-sm text-gray-500">Uses an LLM to identify key entities and relationships in the text.</p></div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-step-icon"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg></div>
                            <div class="flow-step-content"><h4 class="font-bold">3. Build Graph</h4><p class="text-sm text-gray-500">Constructs a knowledge graph from the extracted data.</p></div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-step-icon"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" /></svg></div>
                            <div class="flow-step-content"><h4 class="font-bold">4. Find Communities</h4><p class="text-sm text-gray-500">Summarizes related clusters of information in the graph.</p></div>
                        </div>
                    </div>
                     <div class="mt-8 text-center bg-yellow-50 border border-yellow-200 p-4 rounded-lg">
                        <p class="font-semibold text-yellow-800">The Key Requirement: While GraphRAG can extract a graph from unstructured text, you can also provide a pre-built graph. To do this, you must supply two specifically formatted <strong class="font-bold">Parquet files</strong>: `entities.parquet` and `relationships.parquet`.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="powerquery-path" class="py-20 md:py-24 bg-white">
            <div class="container mx-auto px-4 sm:px-6 lg:px-8">
                <div class="text-center mb-16">
                    <h2 class="text-3xl md:text-4xl font-bold text-gray-900">Path A: The Power Query Workflow</h2>
                    <p class="mt-4 max-w-3xl mx-auto text-lg text-gray-600">Can you prepare the required data using only the tools you already know, like Excel and Power Query? Yes, but with one critical challenge. Here is the step-by-step process.</p>
                </div>
                <div class="max-w-5xl mx-auto">
                    <div class="mb-8 flex flex-wrap justify-center gap-2 border-b border-gray-200">
                        <button class="tab-btn active px-4 py-2 text-sm font-semibold rounded-t-md border-b-2 border-transparent" data-target="pq-step1">Step 1: Load Source Data</button>
                        <button class="tab-btn px-4 py-2 text-sm font-semibold rounded-t-md border-b-2 border-transparent" data-target="pq-step2">Step 2: Create Nodes</button>
                        <button class="tab-btn px-4 py-2 text-sm font-semibold rounded-t-md border-b-2 border-transparent" data-target="pq-step3">Step 3: Create Edges</button>
                        <button class="tab-btn px-4 py-2 text-sm font-semibold rounded-t-md border-b-2 border-transparent" data-target="pq-step4">Step 4: The Export Challenge</button>
                    </div>
                    <div id="pq-tab-content" class="bg-gray-50 p-8 rounded-lg border border-gray-200 min-h-[350px]">
                        <div id="pq-step1" class="pq-tab-pane">
                            <h3 class="font-bold text-xl mb-2 text-gray-800">1. Load Your Transaction Data</h3>
                            <p class="text-gray-600 mb-4">Start by loading your source data (e.g., a CSV or Excel sheet with transaction records) into the Power Query Editor.</p>
                            <p class="text-gray-700">Your source table might look like this:</p>
                            <table class="w-full mt-2 text-sm text-left border-collapse"><thead><tr class="bg-gray-100"><th class="p-2 border">Sender</th><th class="p-2 border">Receiver</th><th class="p-2 border">Amount</th></tr></thead><tbody><tr><td class="p-2 border">Alice</td><td class="p-2 border">Bob</td><td class="p-2 border">100</td></tr><tr><td class="p-2 border">Charlie</td><td class="p-2 border">Alice</td><td class="p-2 border">50</td></tr><tr><td class="p-2 border">Bob</td><td class="p-2 border">David</td><td class="p-2 border">75</td></tr></tbody></table>
                        </div>
                        <div id="pq-step2" class="pq-tab-pane hidden">
                            <h3 class="font-bold text-xl mb-2 text-gray-800">2. Create the `Nodes` Table</h3>
                            <p class="text-gray-600 mb-4">The goal is a unique, numbered list of all entities (people, in this case). This becomes your `entities.parquet` file.</p>
                            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                                <li><strong>Reference</strong> your original query to create two new queries, one for `Senders` and one for `Receivers`. Keep only the respective column in each.</li>
                                <li>Use the **Append Queries** feature to combine `Senders` and `Receivers` into a single new query called `Nodes`.</li>
                                <li>In the `Nodes` query, select the column of names and use **Remove Duplicates** to get a unique list of all entities.</li>
                                <li>From the "Add Column" tab, add an **Index Column** (starting from 0 or 1). This will be the unique `id` for each node.</li>
                            </ol>
                        </div>
                         <div id="pq-step3" class="pq-tab-pane hidden">
                            <h3 class="font-bold text-xl mb-2 text-gray-800">3. Create the `Edges` Table</h3>
                             <p class="text-gray-600 mb-4">Now, create the relationships table. This will become your `relationships.parquet` file, linking nodes by their new IDs.</p>
                            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                                <li>Create another **Reference** to your original transaction query, naming it `Edges`.</li>
                                <li>Use **Merge Queries** to join `Edges` with your `Nodes` table on the `Sender` column. Expand the result to get the `Sender ID`.</li>
                                <li>Repeat the **Merge Queries** step, this time joining on the `Receiver` column to get the `Receiver ID`.</li>
                                <li>Remove the original name columns, leaving you with `source` (Sender ID), `target` (Receiver ID), and any relationship properties like `Amount`.</li>
                            </ol>
                        </div>
                         <div id="pq-step4" class="pq-tab-pane hidden">
                            <h3 class="font-bold text-xl mb-2 text-red-800">4. The Critical Challenge: Exporting to Parquet</h3>
                            <p class="text-gray-600 mb-4">You have successfully created the `Nodes` and `Edges` tables in Power Query. However, Microsoft's GraphRAG requires these as `.parquet` files. This is the main hurdle for a pure MS Office workflow.</p>
                            <div class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4" role="alert">
                              <p class="font-bold">Major Limitation</p>
                              <p>Neither Excel nor Power BI has a built-in, user-facing feature to **"Export as Parquet"**. After preparing your data, you cannot simply save the query results in the required format.</p>
                            </div>
                            <p class="mt-4 text-gray-700">**Potential Workarounds (introduce friction):**</p>
                             <ul class="list-disc list-inside mt-2 space-y-1 text-gray-600">
                                 <li>Load the data into the Power BI data model, then use external tools or Python/R scripts within Power BI to access the model and write to Parquet.</li>
                                 <li>Export the data to CSV from Power Query, then use an online converter or a separate local script to convert the CSV files to Parquet.</li>
                                 <li>Use Power Automate to potentially orchestrate this, but it adds complexity and may require premium connectors.</li>
                             </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="duckdb-path" class="py-20 md:py-24">
            <div class="container mx-auto px-4 sm:px-6 lg:px-8">
                <div class="text-center mb-16">
                    <h2 class="text-3xl md:text-4xl font-bold text-gray-900">Path B: The DuckDB Workflow</h2>
                    <p class="mt-4 max-w-3xl mx-auto text-lg text-gray-600">DuckDB provides a more direct, code-based path that avoids the limitations of a UI-driven tool, particularly the critical export step. The entire process can be handled in a single, powerful script.</p>
                </div>
                 <div class="max-w-4xl mx-auto bg-white p-8 rounded-xl border border-gray-200">
                    <h3 class="text-2xl font-semibold text-center mb-4">The Entire Workflow in One Go</h3>
                     <p class="text-center text-gray-600 mb-6">The following SQL script, executable by DuckDB, performs all the necessary steps: creating nodes, creating edges, and exporting directly to the required Parquet format.</p>
                    <div class="code-block bg-gray-800 text-white p-4 rounded-md text-sm">
<pre><code>-- Step 1: Create the unique Nodes table in memory
CREATE TABLE nodes AS
WITH all_entities AS (
    SELECT Sender AS name FROM 'transactions.csv'
    UNION
    SELECT Receiver AS name FROM 'transactions.csv'
)
SELECT
    row_number() OVER () AS id,
    name
FROM all_entities;

-- Step 2: Create the Edges table using joins with the new node IDs
CREATE TABLE edges AS
SELECT
    n1.id AS source,
    n2.id AS target,
    t.Amount
FROM 'transactions.csv' t
JOIN nodes n1 ON t.Sender = n1.name
JOIN nodes n2 ON t.Receiver = n2.name;

-- Step 3: Export directly to the required Parquet format
COPY (SELECT id, name AS title FROM nodes) TO 'entities.parquet' (FORMAT 'PARQUET');
COPY (SELECT source, target, Amount AS weight FROM edges) TO 'relationships.parquet' (FORMAT 'PARQUET');
</code></pre>
                    </div>
                 </div>
            </div>
        </section>

        <section id="comparison" class="py-20 md:py-24 bg-white">
             <div class="container mx-auto px-4 sm:px-6 lg:px-8">
                <div class="text-center mb-16">
                    <h2 class="text-3xl md:text-4xl font-bold text-gray-900">Definitive Comparison: Power Query vs. DuckDB</h2>
                    <p class="mt-4 max-w-3xl mx-auto text-lg text-gray-600">Choosing the right data preparation tool is a trade-off between familiarity, flexibility, and end-to-end efficiency. Here’s how the two paths stack up.</p>
                </div>
                <div class="max-w-6xl mx-auto overflow-x-auto">
                    <table class="w-full text-left comparison-table">
                        <thead>
                            <tr>
                                <th class="w-1/4">Criterion</th>
                                <th class="w-2/5">Power Query (Excel/Power BI)</th>
                                <th class="w-2/5">DuckDB</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="font-semibold">Ease of Use (for you)</td>
                                <td><span class="font-bold text-green-600">Excellent.</span> As a fluent user, the UI-driven steps for referencing, appending, and merging are intuitive and fast to perform.</td>
                                <td><span class="font-bold text-yellow-600">Good.</span> Requires writing SQL, but the logic is straightforward and mirrors the Power Query steps. A small learning curve yields great power.</td>
                            </tr>
                            <tr>
                                <td class="font-semibold">End-to-End Workflow</td>
                                <td><span class="font-bold text-red-600">Fragmented.</span> Excels at transformation but hits a hard wall at the "Export to Parquet" step, requiring manual workarounds that break the flow.</td>
                                <td><span class="font-bold text-green-600">Seamless.</span> A single script can handle ingestion, transformation, and export to the exact format required by GraphRAG. Highly efficient.</td>
                            </tr>
                             <tr>
                                <td class="font-semibold">Performance & Scalability</td>
                                <td><span class="font-bold text-yellow-600">Good for Moderate Data.</span> Power Query is powerful but can become slow with very large datasets (millions of rows) within the Excel/Power BI environments.</td>
                                <td><span class="font-bold text-green-600">Excellent.</span> Built for analytics. Its columnar, vectorized engine is exceptionally fast and can handle datasets much larger than available RAM by spilling to disk.</td>
                            </tr>
                            <tr>
                                <td class="font-semibold">Automation & Repeatability</td>
                                <td><span class="font-bold text-yellow-600">Possible but Complex.</span> Can be automated with Power Automate or scheduled refresh in Power BI Service, but the export step remains a manual or complex-to-automate gap.</td>
                                <td><span class="font-bold text-green-600">Excellent.</span> The SQL script is inherently repeatable. It can be easily integrated into tools like `dbt` for robust, version-controlled, and scheduled data pipelines.</td>
                            </tr>
                              <tr>
                                <td class="font-semibold">Flexibility & Power</td>
                                <td><span class="font-bold text-yellow-600">Good.</span> The Power Query UI handles most common transformations. Advanced logic requires writing in the M language, which is less common than SQL.</td>
                                <td><span class="font-bold text-green-600">Excellent.</span> The full expressive power of SQL is available for complex joins, window functions, and aggregations, offering higher flexibility for complex scenarios.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

         <section id="recommendation" class="py-20 md:py-24">
            <div class="container mx-auto px-4 sm:px-6 lg:px-8">
                 <div class="text-center mb-16">
                    <h2 class="text-3xl md:text-4xl font-bold text-gray-900">Final Recommendation: The Strategic Path Forward</h2>
                    <p class="mt-4 max-w-3xl mx-auto text-lg text-gray-600">Your choice depends on your long-term goals. While staying in your comfort zone is tempting, the most effective path aligns with your ultimate objective: a powerful, scalable, and maintainable GraphRAG system.</p>
                </div>
                <div class="max-w-4xl mx-auto grid md:grid-cols-2 gap-8">
                    <div class="bg-white p-8 rounded-lg border border-gray-200">
                        <h3 class="font-semibold text-xl mb-3">Stick with Power Query if...</h3>
                        <p class="text-gray-600">You are working on a one-off proof-of-concept with a small dataset, and you are willing to perform the final CSV-to-Parquet conversion step manually. This path prioritizes using a familiar UI over creating an efficient, repeatable pipeline.</p>
                    </div>
                    <div class="bg-blue-50 p-8 rounded-lg border border-blue-200 ring-2 ring-blue-100">
                        <h3 class="font-semibold text-xl mb-3 text-blue-800">Switch to DuckDB if... (Recommended)</h3>
                        <p class="text-blue-900">Your goal is to build a serious, scalable, and continuously updated GraphRAG system. The initial effort to learn the basic SQL for this task is minor compared to the immense benefits in speed, scalability, and automation. **DuckDB provides a truly seamless, end-to-end solution for preparing the data exactly as Microsoft's GraphRAG requires.**</p>
                    </div>
                </div>
                 <div class="mt-16 text-center max-w-3xl mx-auto">
                     <h3 class="text-2xl font-semibold">Beyond GraphRAG: Your Data as an Asset</h3>
                     <p class="mt-4 text-gray-600">Regardless of the path you choose, the `Nodes` and `Edges` tables you create are valuable assets. You can load them into Power BI and use a custom Force-Directed Graph visual to explore relationships, or use them as a foundation for other network analysis tasks. Building the graph is a valuable analytical step in itself.</p>
                 </div>
            </div>
        </section>
    </main>
    
    <footer class="bg-gray-100 border-t border-gray-200">
        <div class="container mx-auto py-6 px-4 sm:px-6 lg:px-8 text-center text-gray-500">
            <p>A definitive guide to preparing data for GraphRAG.</p>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const setupTabs = (containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;

                const tabs = container.querySelectorAll('.tab-btn');
                const panes = container.querySelectorAll('.pq-tab-pane');

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        tabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');

                        const targetId = tab.dataset.target;
                        panes.forEach(pane => {
                            if (pane.id === targetId) {
                                pane.classList.remove('hidden');
                            } else {
                                pane.classList.add('hidden');
                            }
                        });
                    });
                });
            };

            setupTabs('powerquery-path');

            const navLinks = document.querySelectorAll('.nav-link');
            const sections = document.querySelectorAll('main > section');

            const observerOptions = {
                root: null,
                rootMargin: '0px',
                threshold: 0.3
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.getAttribute('id');
                        navLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href') === `#${id}`) {
                                link.classList.add('active');
                            }
                        });
                    }
                });
            }, observerOptions);

            sections.forEach(section => {
                observer.observe(section);
            });
        });
    </script>
</body>
</html>
